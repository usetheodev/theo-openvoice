name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install -e ".[dev]"

      - name: Lint (ruff check)
        run: python -m ruff check src/ tests/

      - name: Format check (ruff format)
        run: python -m ruff format --check src/ tests/

      - name: Type check (mypy)
        run: python -m mypy src/

      - name: Unit tests
        run: python -m pytest tests/unit/ -v

  release:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install build tools
        run: pip install hatch

      - name: Extract tag version
        id: tag
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$TAG_VERSION" >> "$GITHUB_OUTPUT"
          echo "Tag version: $TAG_VERSION"

      - name: Verify version match (tag vs pyproject.toml vs __init__.py)
        run: |
          TAG_VERSION="${{ steps.tag.outputs.version }}"

          PYPROJECT_VERSION=$(python -c "
          import tomllib
          with open('pyproject.toml', 'rb') as f:
              data = tomllib.load(f)
          print(data['project']['version'])
          ")

          INIT_VERSION=$(python -c "
          import ast, pathlib
          src = pathlib.Path('src/theo/__init__.py').read_text()
          for node in ast.walk(ast.parse(src)):
              if isinstance(node, ast.Assign):
                  for target in node.targets:
                      if isinstance(target, ast.Name) and target.id == '__version__':
                          print(ast.literal_eval(node.value))
          ")

          echo "Tag:            $TAG_VERSION"
          echo "pyproject.toml: $PYPROJECT_VERSION"
          echo "__init__.py:    $INIT_VERSION"

          if [ "$TAG_VERSION" != "$PYPROJECT_VERSION" ]; then
            echo "ERRO: Tag v$TAG_VERSION nao corresponde a pyproject.toml ($PYPROJECT_VERSION)"
            exit 1
          fi

          if [ "$TAG_VERSION" != "$INIT_VERSION" ]; then
            echo "ERRO: Tag v$TAG_VERSION nao corresponde a __init__.py ($INIT_VERSION)"
            exit 1
          fi

          echo "Versoes consistentes: $TAG_VERSION"

      - name: Verify changelog has entry for this version
        run: |
          VERSION="${{ steps.tag.outputs.version }}"

          if ! grep -q "\[${VERSION}\]" CHANGELOG.md; then
            echo "ERRO: CHANGELOG.md nao contem entrada para versao [$VERSION]"
            echo "Adicione uma secao '## [$VERSION] - YYYY-MM-DD' antes de criar a tag."
            exit 1
          fi

          echo "CHANGELOG.md contem entrada para [$VERSION]"

      - name: Build wheel and sdist
        run: hatch build

      - name: Verify wheel contents
        run: |
          WHEEL=$(ls dist/*.whl)
          echo "Built: $WHEEL"

          python -c "
          import zipfile, sys
          whl = '$(ls dist/*.whl)'
          with zipfile.ZipFile(whl) as z:
              names = z.namelist()
              required = [
                  'theo/__init__.py',
                  'theo/py.typed',
                  'theo/_types.py',
                  'theo/exceptions.py',
                  'theo/proto/stt_worker.proto',
              ]
              missing = [f for f in required if not any(f in n for n in names)]
              if missing:
                  print(f'ERRO: Arquivos faltando no wheel: {missing}')
                  sys.exit(1)
              print(f'Wheel OK: {len(names)} arquivos, todos os criticos presentes')
          "

      - name: Extract release notes from CHANGELOG
        id: notes
        run: |
          VERSION="${{ steps.tag.outputs.version }}"

          # Extrai a secao do CHANGELOG correspondente a esta versao
          # Pega tudo entre ## [X.Y.Z] e a proxima ## [ ou fim do arquivo
          python -c "
          import re, pathlib

          changelog = pathlib.Path('CHANGELOG.md').read_text()
          version = '$VERSION'

          # Pattern: ## [X.Y.Z] ... ate o proximo ## [ ou fim
          pattern = rf'## \[{re.escape(version)}\][^\n]*\n(.*?)(?=\n## \[|\Z)'
          match = re.search(pattern, changelog, re.DOTALL)

          if match:
              notes = match.group(1).strip()
              # Escreve para arquivo para evitar problemas com multiline em shell
              pathlib.Path('release_notes.md').write_text(notes)
              print(f'Release notes extraidas ({len(notes)} chars)')
          else:
              pathlib.Path('release_notes.md').write_text('Release $VERSION')
              print('AVISO: Nao foi possivel extrair notes do CHANGELOG, usando fallback')
          "

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: release_notes.md
          files: |
            dist/*.whl
            dist/*.tar.gz
          fail_on_unmatched_files: true
          generate_release_notes: false

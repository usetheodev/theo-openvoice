# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- One-command installer for Linux/macOS via `curl | sh` using `uv` as backbone (#install-scripts)
- One-command installer for Windows via `irm | iex` using `uv` as backbone (#install-scripts)
- Docker image build script for CPU and GPU (multi-arch linux/arm64,linux/amd64) (#install-scripts)
- Linux distribution build script producing pip wheel + Docker images (#install-scripts)
- Shared build environment script `scripts/env.sh` with VERSION, PLATFORM, DOCKER_REPO vars (#install-scripts)
- Root `install.sh` redirect to `scripts/install.sh` for quick install UX (#install-scripts)
- NVIDIA GPU detection in install scripts with automatic `faster-whisper` extras installation (#install-scripts)
- systemd service setup for Linux installs (configurable via `THEO_NO_SERVICE`) (#install-scripts)
- Windows uninstall support via `THEO_UNINSTALL=1` environment variable (#install-scripts)
- PyPI publish via OIDC trusted publisher in release workflow (#release-ci)
- Docker image build and push to GHCR in release workflow: CPU multi-arch (amd64+arm64) and GPU (amd64) (#release-ci)
- Open-source community files (CODE_OF_CONDUCT.md, SECURITY.md) (#release-oss)
- GitHub issue and pull request templates (#release-oss)
- Docusaurus documentation site scaffold with initial content (#release-oss)

### Changed
- Default Docker registry in `scripts/env.sh` from Docker Hub to GHCR (`ghcr.io/usetheo/theo-openvoice`) (#release-ci)

### Removed
- Ollama-specific build scripts: `build_darwin.sh`, `build_windows.ps1`, `deduplicate_cuda_libs.sh` (#install-scripts)
- Ollama-specific deploy scripts: `tag_latest.sh`, `push_docker.sh`, `.this-is-the-create-dmg-repo` (#install-scripts)

### Fixed
- Package metadata layout in `pyproject.toml` to keep dependencies out of `project.urls` (#release-oss)
- Restored `scripts/generate_proto.sh` for CI proto stub verification (#release-oss)
- Mypy config for optional dependencies in CI (FastAPI, Prometheus, Uvicorn) (#release-oss)
- Mypy overrides for optional runtime integrations (Silero torch hub, websockets client) (#release-oss)
- Proto stub imports now use package-relative paths for CI test discovery (#release-oss)
- Dev dependencies now include FastAPI/Starlette for unit tests (#release-oss)
- Dev dependencies now include python-multipart for FastAPI form parsing in tests (#release-oss)
- Dev dependencies now include prometheus_client and huggingface_hub for unit tests (#release-oss)
- Added GitHub Actions workflows for Docusaurus test/deploy to Pages (#release-oss)
- Added .nojekyll and trailingSlash config for GitHub Pages deployment (#release-oss)

## [0.1.0] - 2026-02-10

### Added
- Proto `tts_worker.proto` definindo servico TTSWorker com `Synthesize` (server-streaming) e `Health` (unario), mensagens `SynthesizeRequest`, `SynthesizeChunk` e `HealthResponse` (#M9-02)
- Stubs protobuf gerados e commitados para TTS: `tts_worker_pb2.py`, `tts_worker_pb2_grpc.py`, `tts_worker_pb2.pyi` (#M9-02)
- Re-exports de mensagens e servicos TTS em `theo.proto.__init__`: `SynthesizeRequest`, `SynthesizeChunk`, `TTSHealthRequest`, `TTSHealthResponse`, `TTSWorkerServicer`, `TTSWorkerStub`, `add_TTSWorkerServicer_to_server` (#M9-02)
- `TTSWorkerServicer` gRPC com `Synthesize` (server-streaming: texto entra, chunks PCM saem) e `Health` (unario), validacao de texto vazio, estimativa de duracao por chunk, deteccao de cancelamento (#M9-02)
- `SynthesizeParams` dataclass tipado para conversao segura de `SynthesizeRequest` proto em parametros de backend (#M9-02)
- Conversores puros TTS em `theo.workers.tts.converters`: `proto_request_to_synthesize_params()`, `audio_chunk_to_proto()`, `health_dict_to_proto_response()` (#M9-02)
- Entry point de worker TTS como subprocess: `python -m theo.workers.tts` com argparse, porta default 50052, factory `_create_backend()` com engine "kokoro" (#M9-02)
- 25 testes unitarios para TTS worker cobrindo: Synthesize happy path (4), erros (4), Health (3), converters (4), proto roundtrip (4), factory (2), parse_args (2) (#M9-02)
- `KokoroBackend` implementando `TTSBackend` ABC para engine Kokoro: sintese de texto em audio PCM 16-bit com streaming em chunks de 4096 bytes (~85ms a 24kHz) (#M9-03)
- Funcoes helper puras para KokoroBackend: `_resolve_device()`, `_synthesize_with_model()`, `_extract_audio_array()` (suporta ndarray, dict e objeto), `_float32_to_pcm16_bytes()` com clipping protection (#M9-03)
- Fixture de manifesto `tests/fixtures/manifests/valid_tts_kokoro.yaml` para testes do KokoroBackend (#M9-03)
- 38 testes unitarios para KokoroBackend cobrindo: health, load (sucesso, sem biblioteca, falha, auto device), synthesize (chunks, chunk size, texto vazio, modelo nao carregado, parametros, erros, resultado dict/objeto), voices, unload, resolve device, extract audio array, float32 to PCM16 (#M9-03)
- Endpoint `POST /v1/audio/speech` para sintese TTS compativel com contrato OpenAI Audio API (#M9-04)
- Pydantic `SpeechRequest` model com validacao de campos: model, input, voice, response_format, speed (#M9-04)
- Helper `_synthesize_via_grpc()` para comunicacao gRPC com worker TTS via server-streaming (#M9-04)
- Conversao PCM-to-WAV via `_pcm_to_wav()` para formato de resposta WAV (#M9-04)
- Conversores TTS em `theo.scheduler.tts_converters`: `build_tts_proto_request()` e `tts_proto_chunks_to_result()` (#M9-04)
- `TTSSpeakCommand` e `TTSCancelCommand` como comandos cliente para TTS via WebSocket (#M9-05)
- `TTSSpeakingStartEvent` e `TTSSpeakingEndEvent` como eventos servidor para status de sintese TTS (#M9-05)
- Campo `model_tts` em `SessionConfig` e `SessionConfigureCommand` para selecao de modelo TTS por sessao (#M9-05)
- Funcao async `_tts_speak_task()` no endpoint realtime para sintese TTS em background (#M9-05)
- Metodos `mute()` e `unmute()` no `StreamingSession` para mute-on-speak durante TTS (#M9-06)
- Property `is_muted` no `StreamingSession` para consulta de estado de mute (#M9-06)
- `stt_muted_frames_total` Prometheus Counter em `theo.session.metrics` para frames descartados durante mute (#M9-06)
- Integracao full-duplex no endpoint realtime: `tts.speak` dispara mute -> sintese TTS -> chunks de audio -> unmute (#M9-07)
- Suporte a `tts.cancel`: cancela task TTS ativa e unmute STT imediatamente (#M9-07)
- Cancel automatico de TTS anterior quando novo `tts.speak` chega (#M9-07)
- Tratamento de erros TTS: falhas emitem evento `error` com `recoverable: true` e fazem unmute do STT (#M9-07)
- 22 testes em `test_full_duplex.py` cobrindo speak, cancel, ciclo de mute, recovery de erros e edge cases (#M9-07)
- `theo_tts_ttfb_seconds` Histogram para Time to First Byte de TTS (#M9-08)
- `theo_tts_synthesis_duration_seconds` Histogram para duracao total de sintese TTS (#M9-08)
- `theo_tts_requests_total` Counter com label `status` (ok/error/cancelled) para requests TTS (#M9-08)
- `theo_tts_active_sessions` Gauge para sessoes com TTS ativo (#M9-08)
- Flag `HAS_TTS_METRICS` em `theo.scheduler.tts_metrics` com lazy import pattern (#M9-08)
- 16 testes em `test_tts_metrics.py` cobrindo tipos de metricas, disponibilidade e instrumentacao (#M9-08)
- 21 testes em `test_speech_e2e.py` para endpoint REST TTS: happy path, erros e edge cases (#M9-09)
- 17 testes em `test_full_duplex_integration.py` para ciclo de vida full-duplex, operacoes sequenciais, recovery de erros e edge cases (#M9-09)
- ~192 testes novos para M9 (total acumulado: 1600 testes) (#M9-09)
- `SchedulerQueue` com fila de prioridade de dois niveis (REALTIME > BATCH), FIFO dentro do mesmo nivel, aging que promove BATCH apos threshold configuravel (default 30s) (#M8-01)
- `RequestPriority` enum (REALTIME=0, BATCH=1) e `ScheduledRequest` dataclass com cancel_event, enqueue_time e result_future (#M8-01)
- Dispatch loop assincrono no `Scheduler`: background `asyncio.Task` consome fila, despacha para workers via gRPC, resolve futures (#M8-02)
- Pool de canais gRPC no Scheduler com reuso por worker address (#M8-02)
- `Scheduler.submit()` para enfileirar requests com prioridade e obter `asyncio.Future` (#M8-02)
- `CancellationManager` para rastreamento e cancelamento de requests batch: cancel na fila (<1ms) e cancel em execucao via gRPC Cancel RPC (#M8-03, #M8-04)
- Propagacao de cancelamento via `cancel_in_flight()` com gRPC Cancel RPC e timeout de 100ms (#M8-04)
- `BatchAccumulator` para acumulacao de requests BATCH: agrupa por ate 50ms ou max_batch_size, despacha via `asyncio.gather()` (#M8-05)
- `Scheduler._dispatch_batch()` para despacho paralelo de batch de requests ao mesmo worker (#M8-06)
- `LatencyTracker` com timestamps por fase (enqueue, dequeue, grpc_start, complete), TTL cleanup e `LatencySummary` frozen dataclass (#M8-07)
- 7 metricas Prometheus do Scheduler com lazy import: `scheduler_queue_depth` (Gauge), `scheduler_queue_wait_seconds`, `scheduler_grpc_duration_seconds`, `scheduler_cancel_latency_seconds`, `scheduler_batch_size` (Histograms), `scheduler_requests_total` (Counter com labels priority+status), `scheduler_aging_promotions_total` (Counter) (#M8-08)
- Testes de integracao end-to-end do Scheduler: priorizacao, aging, cancelamento na fila e em execucao, batching, shutdown graceful, latency tracking (#M8-09)
- Testes de contencao do Scheduler: batch enfileirado durante realtime, anti-starvation, cancel durante contencao, acumulacao sob carga (#M8-09)
- 191 testes novos para M8 (total: 1408 testes) (#M8-09)

### Changed
- `scripts/generate_proto.sh` atualizado para compilar `tts_worker.proto` alem de `stt_worker.proto` com fix de import path (#M9-02)
- Ruff config: excluidos arquivos gerados `tts_worker_pb2*.py` do linting (#M9-02)
- Mypy config: override para `kokoro.*` (import opcional) (#M9-02)
- Dependencia opcional `kokoro` adicionada ao `pyproject.toml`: `pip install theo-openvoice[kokoro]` (#M9-02)
- `create_app()` factory aceita parametro `worker_manager` para lifecycle de workers TTS (#M9-04)
- Rota `speech.py` registrada no `app.py` para endpoint TTS (#M9-04)
- `dispatch_message()` em `ws_protocol.py` estendido para tratar comandos `tts.speak` e `tts.cancel` (#M9-05)
- Endpoint WebSocket `/v1/realtime` agora suporta full-duplex STT+TTS na mesma conexao (#M9-05)
- `StreamingSession.process_frame()` retorna imediatamente quando muted, pulando preprocessing e VAD (#M9-06)
- `_tts_speak_task()` chama `session.mute()` antes da sintese TTS e `session.unmute()` no bloco finally (#M9-06)
- `Scheduler` evoluido de round-robin trivial (M3) para async dispatch loop com fila de prioridade, cancelamento, batching e metricas (#M8-02)
- `Scheduler.transcribe()` mantem mesma assinatura externa para backward compatibility com API Server (#M8-02)
- Graceful shutdown do Scheduler: `stop()` drena in-flight requests, flush pending batches, cancela dispatch loop (#M8-02)

- `WeNetBackend` implementando `STTBackend` ABC para engine WeNet com arquitetura CTC: transcricao batch via `transcribe_file()` e streaming via `transcribe_stream()` com partials nativos (#M7-01, #M7-02)
- Manifesto `theo.yaml` para WeNet CTC com `architecture: ctc`, `hot_words: true`, `initial_prompt: false`, `word_timestamps: true` (#M7-03)
- Registro do WeNet na factory `_create_backend()` com lazy import para evitar dependencia obrigatoria de `wenet` (#M7-03)
- Flag `--engine wenet` no CLI do worker STT para iniciar subprocess com WeNetBackend (#M7-06)
- Hot words via keyword boosting nativo do WeNet: `WeNetBackend` passa hot words como parametro de decoding (#M7-04)
- Pipeline adaptativo por arquitetura no `StreamingSession`: CTC usa partials nativos (sem LocalAgreement), nao atualiza cross-segment context, nao injeta initial_prompt (#M7-05)
- Metodo `_build_initial_prompt()` no `StreamingSession` com logica por arquitetura: encoder-decoder usa context + hot words; CTC usa apenas hot words sem suporte nativo (#M7-05)
- Testes comparativos de contrato: mesma sessao WebSocket com Whisper e WeNet produz eventos identicos (`transcript.partial`, `transcript.final`, `session.created`, `session.closed`) (#M7-07)
- Testes de streaming avancados com CTC: sequencia partial->final, WAL checkpoint, ring buffer commit, state machine funcional com arquitetura CTC (#M7-08)
- Fixture `valid_stt_wenet_manifest_path` no `conftest.py` para testes que usam manifesto WeNet (#M7-03)
- Dependencia opcional `wenet` no `pyproject.toml`: `pip install theo-openvoice[wenet]` (#M7-10)
- Documentacao `docs/ADDING_ENGINE.md` com guia de 5 passos para adicionar nova engine STT, exemplos de codigo do WeNet, checklist por passo, diagrama ASCII e FAQ com 9 perguntas (#M7-09)
- Secao 4.5.1 "Arquitetura Multi-Engine" no `docs/ARCHITECTURE.md` com tabela de implementacoes, diagrama de extensibilidade, factory pattern e comparacao por arquitetura (#M7-09)

### Added
- `SessionStateMachine` com 6 estados (INIT, ACTIVE, SILENCE, HOLD, CLOSING, CLOSED), transicoes validas, timeouts configuraveis e callbacks on_enter/on_exit (#M6-01)
- `SessionTimeouts` dataclass com defaults do PRD (INIT: 30s, SILENCE: 30s, HOLD: 5min, CLOSING: 2s) e validacao de timeout minimo de 1s (#M6-02)
- Funcao `timeouts_from_configure_command()` para converter campos do `SessionConfigureCommand` (ms) para `SessionTimeouts` (s) (#M6-02)
- `RingBuffer` com array pre-alocado de 60s, ponteiros circulares read/write, read fence e force commit em 90% de capacidade (#M6-04)
- Metodos `check_timeout()` e `update_session_timeouts()` no `StreamingSession` para verificacao periodica de timeouts da state machine (#M6-03)
- Property `session_state` no `StreamingSession` expondo estado atual da maquina de estados (#M6-03)
- Emissao de `SessionHoldEvent` com `hold_timeout_ms` correto quando sessao transita para HOLD (#M6-03)
- 21 testes de integracao em `test_session_state_integration.py` cobrindo transicoes, timeouts, comportamento por estado e emissao de eventos (#M6-03)
- Integracao do Ring Buffer no `StreamingSession`: frames preprocessados escritos no buffer, read fence avanca em transcript.final, force commit automatico quando buffer >90% cheio (#M6-05)
- 32 testes em `test_ring_buffer_fence.py` cobrindo read fence, commit, uncommitted bytes, write protection, force commit callback e integracao StreamingSession + Ring Buffer (#M6-05)
- `SessionWAL` (Write-Ahead Log in-memory) com `WALCheckpoint` frozen dataclass para recovery de sessao sem duplicacao apos crash de worker (#M6-06)
- Integracao do WAL no `StreamingSession`: checkpoint registrado automaticamente apos cada transcript.final com segment_id, buffer_offset e timestamp monotonic (#M6-06)
- Property `wal` no `StreamingSession` para acesso ao WAL pela logica de recovery (#M6-06)
- 17 testes em `test_session_wal.py` cobrindo inicializacao, record/overwrite de checkpoints, imutabilidade do WALCheckpoint e integracao StreamingSession + WAL (#M6-06)
- `LocalAgreementPolicy` para confirmacao de partial transcripts em engines encoder-decoder via comparacao posicional entre passes consecutivas (#M6-08)
- `AgreementResult` dataclass imutavel com tokens confirmados, retidos e flag de nova confirmacao (#M6-08)
- 27 testes em `test_local_agreement.py` cobrindo agreement basico, crescimento monotonico, flush, reset, min_confirm_passes, edge cases e imutabilidade (#M6-08)
- `CrossSegmentContext` para continuidade entre segmentos de fala via initial_prompt com ultimos 224 tokens do transcript.final anterior (#M6-09)
- Integracao do CrossSegmentContext no `StreamingSession`: texto pos-processado (ITN) do transcript.final armazenado automaticamente; initial_prompt combina hot words e contexto no primeiro frame de cada segmento (#M6-09)
- 20 testes em `test_cross_segment_context.py` cobrindo armazenamento, truncamento, reset, integracao com StreamingSession e combinacao de hot words + contexto (#M6-09)
- Recovery de crash do worker via `StreamingSession.recover()`: reabre stream gRPC com timeout, reenvia dados nao commitados do ring buffer, restaura segment_id do WAL, inicia nova receiver task (#M6-07)
- Deteccao automatica de `WorkerCrashError` no receiver com emissao de erro recuperavel e tentativa de recovery transparente (#M6-07)
- 17 testes em `test_session_recovery.py` cobrindo abertura de novo stream, reenvio de uncommitted data, restauracao de segment_id, timeout, prevencao de recursao, integracao receiver+recovery e cenarios de falha (#M6-07)
- Hot words por sessao via `session.configure`: `StreamingSession` aceita `hot_words` que sao injetados como `initial_prompt` para Whisper no primeiro frame de cada segmento, combinados com cross-segment context (#M6-10)
- 9 testes em `test_hot_words_session.py` cobrindo injecao de hot words, formatacao de prompt, combinacao com cross-segment context e update via configure (#M6-10)
- 54 testes de integracao end-to-end em `test_m6_integration.py` cobrindo todos os componentes M6 juntos: state machine + ring buffer + WAL + recovery + cross-segment + hot words + force commit (#M6-11)
- Metricas Prometheus M6: `theo_stt_session_duration_seconds`, `theo_stt_segments_force_committed_total`, `theo_stt_confidence_avg`, `theo_stt_worker_recoveries_total` (#M6-13)
- 18 testes em `test_streaming_metrics.py` cobrindo registro de metricas de sessao, force commit, confidence e recovery (#M6-13)
- Teste de estabilidade de 30 minutos (simulado) com todos os componentes M6: state machine, ring buffer, WAL, cross-segment context, transicoes HOLD, force commit (#M6-15)
- Teste de force commit durante fala continua de 65s excedendo ring buffer de 60s (#M6-15)
- 3 testes de integracao de recovery end-to-end em `test_m6_recovery.py`: continuidade de segment_id, recovery com ring buffer vazio, multiplos recoveries na mesma sessao (#M6-16)

### Changed
- `StreamingSession` agora usa `SessionStateMachine` com 6 estados em vez do estado simplificado ACTIVE/CLOSED de M5 (#M6-03)
- Estado inicial da sessao agora e INIT (aguardando primeiro audio) em vez de ACTIVE (#M6-03)
- VAD speech_start transita INIT->ACTIVE, SILENCE->ACTIVE ou HOLD->ACTIVE (#M6-03)
- VAD speech_end transita ACTIVE->SILENCE (em vez de ser emitido incondicionalmente) (#M6-03)
- Frames recebidos em HOLD nao sao enviados ao worker gRPC (economia de GPU) (#M6-03)
- `check_inactivity()` agora delega para `SessionStateMachine.check_timeout()` em vez de usar timer fixo (#M6-03)
- `close()` agora transita via CLOSING->CLOSED pela state machine (#M6-03)

### Fixed
- SPEECH_END sem SPEECH_START previo nao emitia evento spurio -- agora e ignorado corretamente quando estado nao e ACTIVE (#M6-03)

### Added
- Endpoint WebSocket `WS /v1/realtime` com handshake (model, language, session_id) e protocolo de eventos JSON (#M5-T5-02)
- Pydantic models para 8 tipos de evento servidor e 4 tipos de comando cliente WebSocket (#M5-T5-01)
- Protocol handler `dispatch_message()` para dispatch tipado de frames binarios e comandos JSON (#M5-T5-03)
- Heartbeat WebSocket com ping a cada 10s e timeout de inatividade configuravel (#M5-T5-04)
- `EnergyPreFilter` com RMS + spectral flatness para pre-filtragem de silencio antes do Silero VAD (#M5-T5-05)
- `SileroVADClassifier` com lazy-loading do modelo Silero e sensitivity levels (high/normal/low) (#M5-T5-06)
- `VADDetector` coordenando energy pre-filter + Silero com debounce de fala (250ms) e silencio (300ms) (#M5-T5-07)
- `StreamingPreprocessor` adapter frame-by-frame para preprocessing de audio em streaming (#M5-T5-08)
- `StreamingGRPCClient` e `StreamHandle` para streaming gRPC bidirecional runtime-to-worker com crash detection via stream break (#M5-T5-09)
- `STTWorkerServicer.TranscribeStream` implementado como streaming gRPC bidirecional no worker (#M5-T5-10)
- Conversor `transcript_segment_to_proto_event()` para conversao proto de eventos de streaming (#M5-T5-10)
- `FasterWhisperBackend.transcribe_stream()` para transcricao streaming via acumulacao com threshold de 5s (#M5-T5-11)
- `StreamingSession` orquestrando fluxo completo: preprocessing -> VAD -> gRPC worker -> post-processing -> callback (#M5-T5-12)
- `BackpressureController` com sliding window para deteccao de envio mais rapido que real-time e drop de frames por backlog (#M5-T5-13)
- `StreamingSession.commit()` para force commit manual de segmento via `input_audio_buffer.commit` (#M5-T5-14)
- Metricas Prometheus para streaming: `theo_stt_ttfb_seconds`, `theo_stt_final_delay_seconds`, `theo_stt_active_sessions`, `theo_stt_vad_events_total` (#M5-T5-15)
- 218 testes unitarios cobrindo todos os componentes do M5: eventos, protocolo, heartbeat, VAD, preprocessor, gRPC, session, backpressure, metricas (#M5)
- 83 testes de edge cases para M5: frames vazios/oversized, JSON malformado, double close, use-after-close, debounce de VAD em fronteiras, backpressure com zero-byte frames, conversores proto com defaults, precedencia bytes vs text em WebSocket (#M5-T5-16)
- Teste de estabilidade de sessao de 5 minutos (simulada) validando ausencia de memory leak (<10MB) e degradacao de TTFB (<1.2x) (#M5-T5-18)
- Teste de estabilidade com 200 segmentos curtos validando ausencia de vazamento de recursos em ciclos rapidos de open/close de streams gRPC (#M5-T5-18)
- Property `name` na interface `TextStage` ABC para identificacao de stages no post-processing, simetrica com `AudioStage` (#M4-CR-F03)
- Logging por stage no `PostProcessingPipeline.process()` equivalente ao preprocessing pipeline (#M4-CR-F03)
- Re-exports de `AudioPreprocessingPipeline` e `AudioStage` no `theo.preprocessing.__init__` via `__all__` (#M4-CR-F06)
- Script `scripts/demo_m4.sh` para demo end-to-end da Fase 1: preprocessing + post-processing + API + CLI (#M4-DEMO)

### Changed
- Endpoint WebSocket `/v1/realtime` agora integra `StreamingSession` completo: audio frames passam por backpressure -> preprocessing -> VAD -> gRPC worker -> post-processing (#M5-CR2-01)
- `VADDetector` agora faz debounce por total de samples acumulados em vez de contagem de frames, corrigindo calculo para frames de tamanho variavel (#M5-CR2-03)
- `BackpressureController.clock` tipado como `Callable[[], float]` em vez de `object` para type safety (#M5-CR2-02)
- `_create_streaming_session()` com tipo correto `Callable[[ServerEvent], Awaitable[None]]` para `on_event` (#M5-CR2-01)

### Fixed
- Endpoint WebSocket `/v1/realtime` descartava todos os audio frames recebidos sem processamento — agora integra pipeline completo via `StreamingSession` (#M5-CR2-01)
- Race condition em `StreamingSession._handle_speech_end()` onde `vad.speech_end` podia ser emitido antes de `transcript.final` — agora aguarda receiver task completar (#M5-CR2-02)
- Cancel RPC no servicer tinha mensagem de erro desatualizada referenciando M5 (#M5-CR2-03)
- `SileroVADClassifier._ensure_model_loaded()` nao era thread-safe — adicionado double-check locking com `threading.Lock` (#M5-CR2-05)
- `_handle_speech_start` agora limpa stream/receiver task anteriores antes de abrir novo stream, evitando leak de recursos em duplo SPEECH_START (#M5-CR-01)
- `_proto_event_to_transcript_segment` preserva `start_ms=0` e `end_ms=0` como valores validos em vez de converter para `None` incorretamente (#M5-CR-05)
- `_send_event` aceita qualquer `ServerEvent` em vez de apenas 3 tipos especificos (#M5-CR-02)
- `SessionConfigureCommand` rejeita timeouts negativos e zero com validacao `Field(gt=0)` (#M5-CR-03)
- `BackpressureController` usa duracao do primeiro frame (constante) em vez do frame atual para calculo de taxa efetiva (#M5-CR-08)
- `suppress(Exception)` no fechamento de WebSocket por inatividade restringido para `suppress(WebSocketDisconnect, RuntimeError, OSError)` (#M5-CR-14)
- Logs de `_send_event` agora incluem `session_id` para correlacao (#M5-CR-13)

### Added
- `SileroVADClassifier.preload()` metodo async que carrega o modelo em thread separada via `run_in_executor`, evitando bloqueio do event loop (#M5-CR-10)

### Fixed
- `theo serve` agora instancia pipelines de preprocessing e postprocessing com config toggles antes de criar a app — sem esse fix os pipelines ficavam `None` em producao (#M4-CR-F01)

### Added
- Interface abstrata `AudioStage` ABC para stages plugaveis do Audio Preprocessing Pipeline (#M4-E1-T1)
- Funcoes `decode_audio()` e `encode_pcm16()` para conversao entre bytes de audio e arrays numpy float32 (#M4-E1-T1)
- `AudioPreprocessingPipeline` que orquestra stages em sequencia: decode -> stages -> encode PCM16 WAV (#M4-E1-T1)
- 26 testes unitarios cobrindo AudioStage ABC, decode/encode de audio e pipeline de preprocessamento (#M4-E1-T1)
- `ResampleStage` para conversao de qualquer sample rate para 16kHz via `scipy.signal.resample_poly` (#M4-E1-T2)
- `DCRemoveStage` com filtro Butterworth HPF 2a ordem a 20Hz para remocao de DC offset (#M4-E1-T3)
- `GainNormalizeStage` com peak normalization para -3dBFS e protecao contra clipping (#M4-E1-T4)
- Integracao do Audio Preprocessing Pipeline no fluxo batch: audio preprocessado automaticamente antes do worker (#M4-E1-T5)
- Interface abstrata `TextStage` ABC para stages plugaveis do Post-Processing Pipeline (#M4-E2-T1)
- `PostProcessingPipeline` que orquestra stages de texto em sequencia com suporte a `BatchResult` imutavel (#M4-E2-T1)
- `ITNStage` para Inverse Text Normalization via `nemo_text_processing` com fallback graceful quando pacote nao instalado (#M4-E2-T2)
- Integracao do Post-Processing Pipeline no fluxo batch: texto formatado automaticamente apos transcricao (#M4-E2-T3)
- Parametro `itn` nos endpoints REST `/v1/audio/transcriptions` e `/v1/audio/translations` para controle de ITN por request (#M4-E3-T1)
- Flag `--no-itn` nos comandos CLI `theo transcribe` e `theo translate` para desabilitar ITN (#M4-E3-T1)
- Testes end-to-end validando pipeline completo: audio em qualquer sample rate -> preprocessing -> transcricao -> post-processing -> resposta formatada (#M4-E3-T2)
- FastAPI application factory `create_app()` com injecao de dependencias via Registry e Scheduler (#M3-E1)
- Endpoint `GET /health` retornando status e versao do runtime (#M3-E1)
- Endpoint `POST /v1/audio/transcriptions` compativel com contrato OpenAI Audio API (#M3-E3)
- Endpoint `POST /v1/audio/translations` com task=translate para traducao para ingles (#M3-E3)
- Pydantic models para request/response: `TranscriptionRequest`, `TranslationRequest`, `TranscriptionResponse`, `VerboseTranscriptionResponse` (#M3-E2)
- `ModelRegistry` para scan de modelos em disco, resolucao por nome e listagem de manifestos (#M3-E4)
- `Scheduler` basico que roteia requests para workers disponiveis e converte resultados (#M3-E5)
- Conversor `BatchResult` -> proto `TranscribeFileRequest` no scheduler (#M3-E5)
- Formatos de resposta: `json`, `verbose_json`, `text`, `srt`, `vtt` com formatters dedicados (#M3-E6)
- Error handlers HTTP: 400 (audio invalido), 400 (request invalido), 404 (modelo nao encontrado), 413 (arquivo grande), 503 (worker indisponivel), 500 (erro interno) com formato OpenAI-compatible (#M3-E7)
- `InvalidRequestError` na hierarquia de exceptions para parametros de request invalidos (#M3-CR1)
- CLI: `theo serve` — inicia API Server com workers gRPC para modelos STT instalados (#M3-E8)
- CLI: `theo transcribe <file>` — transcreve arquivo via HTTP com opcoes de formato, idioma e modelo (#M3-E8)
- CLI: `theo translate <file>` — traduz arquivo via HTTP com opcoes de formato e modelo (#M3-E8)
- CLI: `theo list` — lista modelos instalados com tabela formatada (nome, tipo, engine, arquitetura, memoria) (#M3-E8)
- CLI: `theo inspect <model>` — exibe detalhes completos de um modelo instalado (#M3-E8)
- Entry point `theo` via `pyproject.toml` scripts (#M3-E8)
- 18 testes end-to-end validando pipeline completo HTTP -> Scheduler(mock) -> Response para todos os formatos e cenarios de erro (#M3-E9)
- 4 testes de integracao validando compatibilidade com SDK `openai` Python como cliente real (#M3-E10)
- 25 testes unitarios para CLI (serve, transcribe, translate, list, inspect) (#M3-E8)
- Plano estrategico detalhado `docs/STRATEGIC_M3.md` com 5 entregas e 13 tasks (#M3-E0)
- Estrutura de projeto com `pyproject.toml`, src layout e extras opcionais (#M1-I1)
- Tooling: ruff (lint+format), mypy (strict), pytest com pytest-asyncio (#M1-I2)
- CI basico via GitHub Actions com matrix Python 3.11/3.12 (#M1-I3)
- Tipos fundamentais: `STTArchitecture`, `ModelType`, `SessionState`, `VADSensitivity`, `ResponseFormat`, `TranscriptSegment`, `BatchResult`, `EngineCapabilities` (#M1-I4)
- Hierarquia de exceptions tipadas por dominio: `TheoError`, `ConfigError`, `ModelError`, `WorkerError`, `AudioError`, `SessionError` (#M1-I5)
- Parsing e validacao de manifestos `theo.yaml` via `ModelManifest` com Pydantic v2 (#M1-I6)
- Interface abstrata `STTBackend` ABC para engines STT plugaveis (#M1-I7)
- Protobuf gRPC `stt_worker.proto` com servico `STTWorker` (#M1-I7)
- Configuracoes de preprocessing e postprocessing com defaults (#M1-I6)
- Fixtures de teste: audio WAV (16kHz, 8kHz, 44.1kHz) e manifestos YAML (#M1-AUX)
- 56 testes unitarios cobrindo tipos, exceptions, manifesto, configs e contrato STTBackend (#M1-AUX)
- Pipeline de CD: workflow de release via tag `v*` com build de wheel e GitHub Release (#CD-01)
- Build validation no CI: verificacao de conteudo do wheel e consistencia de versao (#CD-02)
- Documentacao de CD pipeline com ADR-011 e estrategia de versionamento (#CD-03)
- Script `scripts/generate_proto.sh` para compilacao de protobuf com fix de import paths (#M2-I1)
- Stubs protobuf gerados e commitados: `stt_worker_pb2.py`, `stt_worker_pb2_grpc.py` (#M2-I1)
- Re-exports em `theo.proto.__init__` para imports limpos de mensagens e servicos gRPC (#M2-I1)
- Structured logging via structlog com formatos JSON e console: `configure_logging()`, `get_logger()` (#M2-AUX)
- Conversores puros proto<->Theo em `theo.workers.stt.converters` (#M2-I2)
- gRPC servicer `STTWorkerServicer` com TranscribeFile, Health e stubs UNIMPLEMENTED (#M2-I2)
- Entry point de worker STT como subprocess: `python -m theo.workers.stt` com argparse (#M2-I2)
- `FasterWhisperBackend` implementando `STTBackend` com transcricao batch, hot words via initial_prompt e conversao PCM->numpy (#M2-I3)
- `WorkerManager` para lifecycle de workers como subprocessos: spawn, health probe com backoff, crash detection, auto-restart com rate limiting e shutdown graceful (#M2-I4)
- 71 novos testes unitarios: converters (12), servicer (11), faster-whisper backend (21), worker manager (16), logging (6), integracao (5) (#M2-I5)
- Verificacao de freshness dos stubs proto no CI (#M2-I1)
- `WorkerCrashError` e `WorkerTimeoutError` na hierarquia de exceptions para erros de worker gRPC (#M3-CR6)
- Modulo `server/constants.py` com constantes centralizadas de limites e content-types (#M3-CR9)
- Modulo `server/routes/_common.py` com logica compartilhada entre rotas de audio (#M3-CR8)
- Testes para gRPC error translation: DEADLINE_EXCEEDED -> WorkerTimeoutError, UNAVAILABLE -> WorkerCrashError (#M3-CR6)
- Testes para HTTP 504 (WorkerTimeout) e 502 (WorkerCrash) nos error handlers (#M3-CR14)
- Testes para validacao de content-type em uploads de audio (#M3-CR10)
- Testes para timestamps negativos e segmentos vazios nos formatters SRT/VTT (#M3-CR22)
- Testes para campo `task` no scheduler e health endpoint com version/models_loaded (#M3-CR7)

### Changed
- Dependencias core: adicionados `click>=8.0` e `httpx>=0.27` para CLI e HTTP client (#M3-E8)
- Dependencias dev: adicionado `openai>=1.0` para testes de compatibilidade com SDK (#M3-E10)
- `pyproject.toml`: filtros de warnings para websockets DeprecationWarning e ResourceWarning (#M3-E10)
- Campos `compression_ratio` e `probability` adicionados aos tipos `SegmentDetail` e `WordTimestamp` (#M2-I0)
- Proto `Segment` e `Word` estendidos com campos `compression_ratio` e `probability` (#M2-I0)
- Dependencias core: adicionados `structlog>=24.0` e `numpy>=1.26` (#M2-I0)
- Dependencias dev: adicionado `types-grpcio>=1.0` para type stubs gRPC (#M2-I0)
- CI instala extras `dev,grpc` para suportar compilacao e testes de proto (#M2-I1)
- Ruff config: excluidos arquivos gerados `stt_worker_pb2*.py` do linting (#M2-I0)
- Mypy config: override para `faster_whisper.*` (import opcional) (#M2-I0)
- README: tabela de compatibilidade com endpoints OpenAI API (#README-01)
- README: secao Quick Start com exemplo minimo de uso (#README-02)
- README: diagrama de arquitetura convertido para Mermaid (#README-03)
- README: licenca atualizada de "A definir" para MIT (consistente com pyproject.toml) (#README-04)

### Fixed
- `response_format` invalido agora retorna 400 com mensagem descritiva em vez de 500 generico (#M3-CR1)
- Endpoints de transcricao e traducao agora rejeitam upload antes de ler arquivo quando `Content-Length` excede limite de 25MB (#M3-CR2)
- Formatters SRT e VTT agora fazem carry correto de milissegundos em timestamps de fronteira (ex: 59.9999s -> 00:01:00,000) (#M3-CR3)
- `STTWorkerServicer.TranscribeFile` agora tem return explicito apos `context.abort` evitando `UnboundLocalError` se abort nao levantar excecao (#M2-CR1)
- Logica duplicada de construcao de comando CLI no `WorkerManager` extraida para `_build_worker_cmd` e `_spawn_worker_process` (#M2-CR2)
- `_check_worker_health` moveu import de `STTWorkerStub` para fora do bloco try, evitando potencial leak de channel gRPC (#M2-CR3)
- Signal handler no worker STT agora protege contra duplo shutdown com flag `shutting_down` e funcao nomeada em vez de lambda (#M2-CR4)
- Background tasks do `WorkerManager` agora sao awaited apos cancel em `stop_worker` e removidas do dict via `_cancel_background_tasks` (#M2-CR5)
- Subprocess do worker usa `DEVNULL` em vez de `PIPE` para stdout/stderr, eliminando risco de deadlock quando worker gera output (#M2-CR6)
- `_attempt_restart` nao cancela mais as proprias background tasks (self-cancellation bug), substitui diretamente no dict (#M2-CR7)
- gRPC channel options no Scheduler: max_receive_message_length=30MB, keepalive_time=30s, keepalive_timeout=10s (#M3-CR4)
- gRPC timeout proporcional ao tamanho do audio no Scheduler: base 30s + 1s/MB (#M3-CR5)
- gRPC DEADLINE_EXCEEDED traduzido para `WorkerTimeoutError` e UNAVAILABLE para `WorkerCrashError` no Scheduler (#M3-CR6)
- Campo `task` agora propagado no proto `TranscribeFileRequest` para diferenciar transcribe/translate (#M3-CR7)
- Rotas de transcricao e traducao deduplicadas via modulo `_common.py` com `handle_audio_request()` (#M3-CR8)
- Constantes `MAX_FILE_SIZE_BYTES` e `ALLOWED_AUDIO_CONTENT_TYPES` centralizadas em `server/constants.py` (#M3-CR9)
- Content-type de upload validado contra frozenset de tipos permitidos antes de ler arquivo (#M3-CR10)
- Leitura de arquivo com limite `MAX_FILE_SIZE_BYTES + 1` para prevenir OOM em uploads sem Content-Length (#M3-CR11)
- Dependencias (`get_registry`, `get_scheduler`) agora fazem fail-fast com `InvalidRequestError` se None (#M3-CR12)
- Error handlers incluem `exc_info=True` e `request_id` para correlacao de logs (#M3-CR13)
- `WorkerTimeoutError` retorna HTTP 504 (Gateway Timeout) em vez de 503 generico (#M3-CR14)
- `WorkerCrashError` retorna HTTP 502 (Bad Gateway) com header `Retry-After: 5` (#M3-CR15)
- `theo serve` agora faz bind em `127.0.0.1` por default em vez de `0.0.0.0` (#M3-CR16)
- Shutdown graceful do CLI serve usa `loop.add_signal_handler` em vez de `signal.signal` para compatibilidade com asyncio (#M3-CR17)
- Worker stderr capturado via `subprocess.PIPE` e logado (ultimos 2000 chars) em caso de crash (#M3-CR18)
- Health endpoint retorna campo `version` (via `theo.__version__`) e `models_loaded` quando registry disponivel (#M3-CR19)
- Versao do CLI centralizada via `theo.__version__` eliminando string duplicada (#M3-CR20)
- `DEFAULT_MODELS_DIR` deduplicado entre `cli/serve.py` e `cli/models.py` (#M3-CR21)
- Formatters SRT e VTT agora ignoram segmentos com texto vazio/whitespace-only (#M3-CR22)
- Formatters SRT e VTT clampeiam timestamps negativos para zero (#M3-CR23)
- Conversor proto usa `probability` 0.0 como default em vez de campo ausente para `no_speech_prob` (#M3-CR24)
